\documentclass[12pt]{report}
\usepackage{uwmthesis}
\usepackage[colorlinks=true]{hyperref}
\usepackage{stmaryrd}
\usepackage{listings}
\lstset{
	mathescape,
	basicstyle=\small
}

\usepackage[square,numbers]{natbib}
\bibliographystyle{plainnat}

\begin{document}

\title{Mechanizing WebAssembly Proposals}
\author{Jacob Mischka}
\degree{Master of Science}
\Program{Computer Science}
\majorprof{John Boyland}
\algorithmspagefalse

\Abstract{% TODO
}


\beforepreface

\prefacesection{Preface}

% TODO

\Acks{%
	% TODO
}

\afterpreface

\chapter{Introduction}

With the only standardized and widely supported language for the Web being
JavaScript, it became more common for other languages to support JavaScript as
a compile target, with developers writing software in those other languages and
compiling the software to JavaScript to run on the Web.
Some of these source languages were designed intentionally with this goal in
mind, such as CoffeeScript.
The goals of these projects were to provide developers the same distribution
platform (the Web) but with the freedom of writing their programs in a
different syntax.
However, with the usage of the Web as a universal platform continued to expand,
authors of other projects wished to compile their software to be run on the
Web, but had strong reasons requiring the use of a different source language.
Often, this was a lower-level language used for
performance reasons, a stricter language for safety reasons, or support for
existing libraries or large projects in existing languages that cannot easily
be ported to JavaScript.
Often, this language is C or C++.

The Emscripten project compiles LLVM\footnote{\url{http://llvm.org/}} intermediate representation
software, which can be generated from C/C++, to JavaScript\cite{AboutEmscripten}.
The resulting compiled program utilizes a subset of JavaScript's available syntax and operations,
called asm.js,
which are heavily optimized by JavaScript interpreters and just-in-time compilers,
as well as the underlying hardware\cite{AsmJsResig}.

While this clever usage of the existing platform provided performance imrovements, JavaScript was
not designed as a low-level, performant compile target, and the resulting benefits of asm.js
relied heavily on JavaScript runtime implementations.
An attempt to define a formal specification and standardize the platform began
in 2013, but was abandoned shortly thereafter in 2014\cite{AsmJsSpec}.

The abandonment of asm.js's formalization coincided with discussions amongst its project
leaders for defining a new ``proper'' bytecode solution for native code on the Web; followed
shortly thereafter by initial discussions between browser developers and JavaScript runtime implementers
about ``WebAsm''.
As this project evolved and was fleshed out, the WebAssembly project began and was announced publicly
on June 17, 2015\cite{HistoryWasmTalk}.

\chapter{WebAssembly}

WebAssembly (Wasm) is a ``safe, portable, low-level code format designed for
efficient execution and compact representation''\cite[p. 1]{WasmSpec}.
WebAssembly defines a virtual instruction set that encapsulates programs
with it as their target, making them independent of the underlying platform
on which the program runs.
WebAssembly programs are executed by \textit{embedding environments}, which provide
an abstraction layer between the program and the underlying system. % FIXME: pluralization?

WebAssembly supports two official formats: a readable text format and a
more efficient binary format.

% TODO: Define embedders, VMs

In order to interact with the environment, WebAssembly embeddings
expose functionality via application programming interfaces (APIs):
defined functions that WebAssembly can use to interact with the environment.
With the Web as the primary embedding environment, Web embeddings provide
a defined JavaScript API that allows interaction between web pages.

WebAssembly provides safety guarantees by fully encapsulating logic and execution
at a low level.
Values consist of only 32- and 64-bit variants of integers and floating point
numbers\cite[p. 2--3]{WasmSpec}.
The operational semantics of the language is primarily that of a stack machine,
wherein operations are performed by removing operands from a last-in-first-out
stack of values and pushing the operation's result onto the stack afterward.
Strictly speaking this is not completely true, as the language's inclusion of
local variables allows circumvention of completely stack-based
execution\cite{WasmNotStackMachine}.
This has led to challenges for implementors of Lightbeam, an optimizing streaming
WebAssembly compiler\cite{IntroducingLightbeam}.

Memory operations are fully sandboxed by the WebAssembly execution environment.

% More advanced datatypes can be supported by building upon
% the fundamental language components.


Embedding environments are free to expose any level of functionality to WebAssembly.

% TODO: Describe memory model

\section{Non-Web Embeddings}

As its name implies, its primary focus is Web-based software; however it is not
specific or tied to the Web.
Other non-Web environments execute WebAssembly for a variety of reasons: its
safe memory model, its high performance, and it being a universal, encapsulated,
and independent compile target.
The last is particularly interesting given its bidirectional implications: a
programmer can truly write and compile a piece of software once and run it
nearly anywhere; and a programmer can depend on other software written in any
language that supports WebAssembly.

WASI (WebAssembly System Interface) is a project that defines a family of APIs
for WebAssembly to interact with a traditional system environment to perform
common, core tasks such as interaction with the filesystem and networking\cite{WasiOverview}.
These APIs are designed to be a common target for embedders to support, allowing optimal
portability of systems-focused WebAssembly programs.


\section{Evolving WebAssembly}

The defined goals of the WebAssembly project details the process for evolving the language:
incrementally after providing a minimum viable product (MVP) core language specification and
implementation\cite{WasmHighLevelGoals}.
For the release of the 1.0 MVP, the main requirements of being a well-defined replacement for asm.js
with distributable modules, efficient binary bytecode, and high performance were the focus\cite{WasmMvp}.

Development of the specification takes place in public GitHub repositories.
Version 1.0 of the specification was tagged on July 20, 2019\cite{WasmWg1.0Release}.

While a large list of future features are at various levels of consideration for post-MVP Wasm,
the Community Group and Working Group utilize a phase-based proposal system for introducing,
discussing, and implementing additional features for WebAssembly\cite{WasmFutureFeatures}.

For a feature to be adopted into the language, a proposal must be drafted which passes through a sequence
of phases\cite{WasmW3CProcess}:

% FIXME: Update this when https://github.com/WebAssembly/meetings/pull/561 is merged
\begin{enumerate}
	\item[0] \textbf{Pre-Proposal}:
		A Community Group member files
		an issue to present the idea, and a proposal champion or champions
		emerges which submits the proposal to the Community Group's biweekly agenda.
		After being approved for general interest of research by the group,
		a proposal repository is created in the WebAssembly GitHub organization.

	\item[1] \textbf{Feature Proposal}:
		The proposal's repository is used to facilitate discussion about, and design and specification
		of, the feature.

	\item[2] \textbf{Proposed Specification Text Available}:
		Once the full proposed English specification text is available, prototype implementations
		for are created so that a test suite can be added for the new feature.

	\item[3] \textbf{Implementation Phase}:
		After a satisfactory test suite is created and passes for the feature in some implementation,
		embedders implement the feature and integrate the changes into the reference WebAssembly interpreter.

	\item[4] \textbf{Standardize the Feature}:
		After Web VMs and toolchains implement the feature and
		the Community Group reaches consensus for the feature and its design choices,
		the feature is handed off to the Working Group for final stages of discussion
		and handling of edge cases.
		The Community Group is responsible for major feature changes
		and design decisions, so the proposal is essentially frozen once being passed
		to the Working Group.

	\item[5] \textbf{The Feature is Standardized}:
		Consensus is reached by the Working Group that the feature is complete.
\end{enumerate}


\chapter{Soundness}

Core WebAssembly's type system has been proven sound both via a natural language
proof\cite[p. 140]{WasmSpec}, as well as a mechanized proof in
Isabelle\cite{WattMechanizing}.
In addition to proving soundness of the core language via progress and
preservation, the original mechanization included several notable
additional properties.

Firstly, it included one proposal not existing in the initial version of the core language:
the Multi-value Proposal\cite{MultiValueProposal}.
In the original specification, functions and instructions can return at most one result.
This restriction is removed by the Multi-value Proposal, allowing multiple return
values for each\cite{MultiValueOverview}.

In addition to the soundness proof of the core language, the initial mechanization
included two separate modules which were also proven sound: an executable type
checker\cite[p. 61]{WattMechanizing} and an executable
interpreter\cite[p.62]{WattMechanizing}.



\chapter{Incremental Soundness} % TODO

This work builds on the existing Isabelle proof, extending the initial
mechanization to include extensions provided by several late-stage proposals.
Definitions and proofs for the type checker and interpreter are also updated
accordingly.

At the outset of this project, two (non-trapping int-to-float
conversions\cite{NontrappingFloatToIntProposal} and sign exension
operations\cite{SignExtensionOpsProposal}) of the newly-mechanized proposals,
along with the multi-value proposal already present in the initial mechanization,
were at stage 4 and have been moved to stage 5 and integrated
into version 1.1 of the WebAssembly specification as of April 9,
2020\cite{Phase5Advancement}.


\section{Non-trapping Float-to-Int Conversions} % TODO

The first of the three mechanized, this proposal introduces 8 new saturating
floating point truncation instructions of the form \\
\texttt{\textit{(destination type)}.trunc\_sat\_\textit{(source type)}\_\textit{(signedness)}}%
\cite{NontrappingFloatToIntOverview}:

\begin{itemize}
	\item \texttt{i32.trunc\_sat\_f32\_s}
	\item \texttt{i32.trunc\_sat\_f32\_u}
	\item \texttt{i32.trunc\_sat\_f64\_s}
	\item \texttt{i32.trunc\_sat\_f64\_u}
	\item \texttt{i64.trunc\_sat\_f32\_s}
	\item \texttt{i64.trunc\_sat\_f32\_u}
	\item \texttt{i64.trunc\_sat\_f64\_s}
	\item \texttt{i64.trunc\_sat\_f64\_u}
\end{itemize}

Non-saturating versions of these instructions were present in the initial
release of WebAssembly, though were defined to trap in the event that
the floating point number could not be represented in the target integer type's
possible range of values, or in the event that the floating point number was
\texttt{NaN}.
These new instructions instead return the minimum or maximum target integer
value in case of underflow or overflow, and 0 in the event that the source floating
point number is \texttt{NaN}, resulting in operations that never fail.

In the original mechanization, all numeric conversion instructions are
handled in a single \texttt{convert} function, which performs the appropriate
operations for the given instruction.
Because the non-saturating truncation instructions can fail, resulting in a trap,
this function returns an \texttt{Option} value, indicating \texttt{Some} value
if the conversion succeeded or \texttt{None} otherwise.
Because these new instructions do not trap, I initially set out to model the
\texttt{convert\_sat} collection of operations so that they did not return an
\texttt{Option} and simply returned a value in all cases.
This was a mistake, as \texttt{convert} returns \texttt{None} not only
when the conversion failed, but also when no such instruction exists
to perform the conversion for the given types, such as a hypothetical
conversion from an \texttt{f64} to an \texttt{f64}.
In order for the new saturating conversion function to fit nicely
into the existing mechanization, it must to be able to return \texttt{None}
when the operation was impossible, such as converting to the same type as
the original input type.
After struggling to modify the surrounding proofs to handle such impossible
conversions elsewhere, reverting \texttt{convert\_sat} to return an
\texttt{Option} but always returning \texttt{Some} value when performing
a truncation resulted in a straightforward addition which maintained the
language's proof of soundness without requiring drastic changes to the
surrounding theorems and lemmas.

\begin{lstlisting}
datatype
  cvtop = Convert | ConvertSat | Reinterpret
  ...
(* TYPING RELATION *)
inductive b_e_typing ::
	"[t_context, b_e list, tf] $\Rightarrow$ bool" ("_ $\vdash$ _ : _" 60)
where ...
  | convert:"$\llbracket$(t1 $\neq$ t2); (sx = None) =
	((is_float_t t1 $\land$ is_float_t t2)
		$\lor$ (is_int_t t1 $\land$ is_int_t t2
			$\land$ (t_length t1 < t_length t2)))$\rrbracket$
	$\Longrightarrow$ $C$ $\vdash$ [Cvtop t1 Convert t2 sx] : ([t2] $\to$ [t1])"
  | convert_sat:"$\llbracket$(t1 $\neq$ t2); (sx = None) =
	((is_float_t t1 $\land$ is_float_t t2)
		$\lor$ (is_int_t t1 $\land$ is_int_t t2
			$\land$ (t_length t1 < t_length t2)))$\rrbracket$
	$\Longrightarrow$ $C$ $\vdash$ [Cvtop t1 ConvertSat t2 sx] : ([t2] $\to$ [t1])"
\end{lstlisting}

\section{Sign Extension Operators} % TODO

Similarly to the previous proposal, the Sign Extension Operators proposal
introduces several new numeric conversion operations which are similar to
existing instructions\cite{SignExtensionOpsOverview}:

\begin{itemize}
	\item \texttt{i32.extend8\_s}: extend a signed 8-bit integer to a 32-bit integer
	\item \texttt{i32.extend16\_s}: extend a signed 16-bit integer to a 32-bit integer
	\item \texttt{i64.extend8\_s}: extend a signed 8-bit integer to a 64-bit integer
	\item \texttt{i64.extend16\_s}: extend a signed 16-bit integer to a 64-bit integer
	\item \texttt{i64.extend32\_s}: extend a signed 32-bit integer to a 64-bit integer
\end{itemize}

Already present in the MVP release of WebAssembly are \texttt{i64.extend\_s}
and \texttt{i64.extend\_u}\cite[p. 11]{WasmSpec}, for extending a 32-bit
integer value (signed or unsigned, respectively) to a 64-bit integer value.
At first inspection, this seems like the only extension operations required,
as WebAssembly only supports 32- and 64-bit integers.
These new instructions, by contrast, do not actually modify the type of the
value, instead only its contents: \texttt{i32.extend8\_s} receives an
\texttt{i32} as input and returns an \texttt{i32} as output.
These new instructions reinterpret the contents of a value, operating
on smaller signed integer values packed inside the bits of one of
WebAssembly's integer types.
%                     â†“ Impossible?
While such cases are unlikely when using pure WebAssembly,
interaction with other environments or languages may result in
such values existing.

The distinction is initially confusing.
In fact, the distinction was even missed in initial discussions for this
proposal, resulting in \texttt{i64.extend32\_s} being dismissed as equivalent
to the existing \texttt{i64.extend\_s} instruction.
However, because the former receives a 32-bit integer as input, the latter
is indeed a distinct operation, and was hence added to the proposal
afterward\cite{SignExtensionOpsOverview}.

\section{Tail Call} % TODO

On the surface, this proposal seems almost as straightforward as the previous two.
The new instructions do not introduce any completely new behavior, they merely
combine existing behavior.
Core WebAssembly explicitly disallows tail call optimizations

During the mechanization of this proposal, a mistake in the specification was noticed.
Before unwinding the stack when performing the return portion of the operation,
the values which are to be passed to the function being tail-invoked must first
be removed and then replaced after the frame of the ending function body is removed.
Before popping these values off the stack, it must be asserted that these values exist
in the correct number ($n$).
Initially, the specification mistakenly required that the stack must contain values
in number of the tail-invoked function's returned type instead of its input type,
but correctly removed $n$ values.
Thus, as initially written, the operation performed the correct operation, but did not check
that it was possible beforehand, resulting in unsafe operation.
This mistake was brought to the attention of the maintainers and was fixed
shortly thereafter\cite{TailInvokeIssue10}.

\chapter{Conclusions} % TODO

\chapter{Related Work} % TODO

\chapter{Future Work} % TODO

\chapter{Summary} % TODO

% \appendix

\clearpage

\bibliography{thesis,wasm-cg}
\addcontentsline{toc}{chapter}{Bibliography}

\end{document}
