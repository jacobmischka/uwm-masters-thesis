\documentclass[12pt]{report}
\usepackage{uwmthesis}
\usepackage[colorlinks=true]{hyperref}

\usepackage[square,numbers]{natbib}
\bibliographystyle{plainnat}

\begin{document}

\title{Mechanizing WebAssembly Proposals}
\author{Jacob Mischka}
\degree{Master of Science}
\Program{Computer Science}
\majorprof{John Boyland}
\algorithmspagefalse

\Abstract{% TODO
}


\beforepreface

\prefacesection{Preface}

% TODO

\Acks{%
	% TODO
}

\afterpreface

\chapter{Introduction}

With the only standardized and widely supported language for the Web being
JavaScript, it became more common for other languages to support JavaScript as
a compile target, with developers writing software in those other languages and
compiling the software to JavaScript to run on the Web.
Some of these source languages were designed intentionally with this goal in
mind, such as CoffeeScript.
The goals of these projects were to provide developers the same distribution
platform (the Web) but with the freedom of writing their programs in a
different syntax.
However, with the usage of the Web as a universal platform continued to expand,
authors of other projects wished to compile their software to be run on the
Web, but had strong reasons requiring the use of a different source language.
Often, this was a lower-level language used for
performance reasons, a stricter language for safety reasons, or support for
existing libraries or large projects in existing languages that cannot easily
be ported to JavaScript.
Often, this language is C or C++.

The Emscripten project compiles LLVM\footnote{\url{http://llvm.org/}} intermediate representation
software, which can be generated from C/C++, to JavaScript\cite{AboutEmscripten}.
The resulting compiled program utilizes a subset of JavaScript's available syntax and operations,
called asm.js,
which are heavily optimized by JavaScript interpreters and just-in-time compilers,
as well as the underlying hardware\cite{AsmJsResig}.

While this clever usage of the existing platform provided performance imrovements, JavaScript was
not designed as a low-level, performant compile target, and the resulting benefits of asm.js
relied heavily on JavaScript runtime implementations.
An attempt to define a formal specification and standardize the platform began
in 2013, but was abandoned shortly thereafter in 2014\cite{AsmJsSpec}.

The abandonment of asm.js's formalization coincided with discussions amongst its project
leaders for defining a new ``proper'' bytecode solution for native code on the Web; followed
shortly thereafter by initial discussions between browser developers and JavaScript runtime implementers
about ``WebAsm''.
As this project evolved and was fleshed out, the WebAssembly project began and was announced publicly
on June 17, 2015\cite{HistoryWasmTalk}.

\chapter{WebAssembly}

WebAssembly (Wasm) is a ``safe, portable, low-level code format designed for
efficient execution and compact representation''\cite[p. 1]{WasmSpec}.
WebAssembly defines a virtual instruction set that encapsulates programs
with it as their target, making them independent of the underlying platform
on which the program runs.
WebAssembly programs are executed by \textit{embedding environments}, which provide
an abstraction layer between the program and the underlying system. % FIXME: pluralization?

WebAssembly supports two official formats: a readable text format and a
more efficient binary format.

% TODO: Define embedders, VMs

In order to interact with the environment, WebAssembly embeddings
expose functionality via application programming interfaces (APIs):
defined functions that WebAssembly can use to interact with the environment.
With the Web as the primary embedding environment, Web embeddings provide
a defined JavaScript API that allows interaction between web pages.

WebAssembly provides safety guarantees by fully encapsulating logic and execution
at a low level.
Values consist of only 32- and 64-bit variants of integers and floating point
numbers\cite[p. 2--3]{WasmSpec}.
The operational semantics of the language is primarily that of a stack machine,
wherein operations are performed by removing operands from a last-in-first-out
stack of values and pushing the operation's result onto the stack afterward.
Strictly speaking this is not completely true, as the language's inclusion of
local variables allows circumvention of completely stack-based
execution\cite{WasmNotStackMachine}.
This has led to challenges for implementors of Lightbeam, an optimizing streaming
WebAssembly compiler\cite{IntroducingLightbeam}.

Memory operations are fully sandboxed by the WebAssembly execution environment.

% More advanced datatypes can be supported by building upon
% the fundamental language components.


Embedding environments are free to expose any level of functionality to WebAssembly.

% TODO: Describe memory model

\section{Non-Web Embeddings}

As its name implies, its primary focus is Web-based software; however it is not
specific or tied to the Web.
Other non-Web environments execute WebAssembly for a variety of reasons: its
safe memory model, its high performance, and it being a universal, encapsulated,
and independent compile target.
The last is particularly interesting given its bidirectional implications: a
programmer can truly write and compile a piece of software once and run it
nearly anywhere; and a programmer can depend on other software written in any
language that supports WebAssembly.

WASI (WebAssembly System Interface) is a project that defines a family of APIs
for WebAssembly to interact with a traditional system environment to perform
common, core tasks such as interaction with the filesystem and networking\cite{WasiOverview}.
These APIs are designed to be a common target for embedders to support, allowing optimal
portability of systems-focused WebAssembly programs.


\section{Evolving WebAssembly}

The defined goals of the WebAssembly project details the process for evolving the language:
incrementally after providing a minimum viable product (MVP) core language specification and
implementation\cite{WasmHighLevelGoals}.
For the release of the 1.0 MVP, the main requirements of being a well-defined replacement for asm.js
with distributable modules, efficient binary bytecode, and high performance were the focus\cite{WasmMvp}.
While a large list of future features are at various levels of consideration for post-MVP Wasm,
the Community Group and Working Group utilize a phase-based proposal system for introducing,
discussing, and implementing additional features for WebAssembly\cite{WasmFutureFeatures}.

For a feature to be adopted into the language, a proposal must be drafted which passes through a sequence
of phases\cite{WasmW3CProcess}:

\begin{enumerate}
	\item[0] \textbf{Pre-Proposal}:
		A Community Group member files
		an issue to present the idea, and a proposal champion or champions
		emerges which submits the proposal to the Community Group's biweekly agenda.
		After being approved for general interest of research by the group,
		a proposal repository is created in the WebAssembly GitHub organization.

	\item[1] \textbf{Feature Proposal}:
		The proposal's repository is used to facilitate discussion about, and design and specification
		of, the feature.

	\item[2] \textbf{Proposed Specification Text Available}:
		Once the full proposed English specification text is available, prototype implementations
		for are created so that a test suite can be added for the new feature.

	\item[3] \textbf{Implementation Phase}:
		After a satisfactory test suite is created and passes for the feature in some implementation,
		embedders implement the feature and integrate the changes into the reference WebAssembly interpreter.

	\item[4] \textbf{Standardize the Feature}:
		After Web VMs and toolchains implement the feature and
		the Community Group reaches consensus for the feature and its design choices,
		the feature is handed off to the Working Group for final stages of discussion
		and handling of edge cases.
		The Community Group is responsible for major feature changes
		and design decisions, so the proposal is essentially frozen once being passed
		to the Working Group.

	\item[5] \textbf{The Feature is Standardized}:
		Consensus is reached by the Working Group that the feature is complete.
\end{enumerate}


\chapter{Soundness}

Core WebAssembly's type system has been proven sound both via a natural language
proof\cite[p. 140]{WasmSpec}.

A mechanized proof in Isabelle supports the proofs with a high level of
eyeball-closeness\cite{WattMechanizing}.

\chapter{Incremental Soundness} % TODO

This work builds on the existing Isabelle proof of the core language, extending the initial
mechanization to include extensions provided by several late-stage proposals.
At the outset of this project, two (non-trapping int-to-float
conversions\cite{NontrappingFloatToIntProposal} and sign exension
operations\cite{SignExtensionOpsProposal})
were at stage 4, though have been moved to stage 5 and have been integrated into the WebAssembly
specification as of April 9 2020\cite{Phase5Advancement}.

\section{Non-trapping Int-to-Float Conversions} % TODO

The first of the three mechanized, this proposal introduces 8 new saturating
float truncation instructions; one for each of the combination of the three
associated variables in the form \texttt{i32.trunc\_sat\_f32\_s}:
float type (32- or 64-bit), integer type (32- or 64-bit),
and signedness (signed or unsigned)\cite{NontrappingFloatToIntOverview}.
Non-saturating versions of these instructions were present in the initial
release of WebAssembly, though were defined to trap in the event that
the floating point number could not be represented in the target integer type's
possible range of values, or in the event that the floating point number was
\texttt{NaN}.
These new instructions instead simply return the minimum or maximum target integer
value in case of underflow or overflow, and 0 in the event that the source floating
point number is \texttt{NaN}.

The mechanization for the original \texttt{convert} instructions return an
\texttt{Option} value, indicating \texttt{Some} value if the conversion
succeeded or \texttt{None} otherwise.
Because these new instructions do not trap, I initially wanted to model my
\texttt{convert\_sat} collection of operations so that they did not return an
\texttt{Option} and simply returned a value in all cases.
This was a mistake, as \texttt{convert} returned \texttt{None} not only
when the conversion failed, but also when no such instruction exists
to perform the conversion.
In order for the new saturating conversion function to fit nicely
into the original mechanization, it needed to be able to return \texttt{None}
when the operation was impossible, such as converting to the same type as
the original input type.
After struggling for a while, reverting \texttt{convert\_sat} to return an
\texttt{Option} but simply always returning \texttt{Some} value when performing
a truncation resulted in a straightforward addition which maintained the
language's proof of soundness.

\section{Sign Extension Operations} % TODO

\section{Tail Call} % TODO

On the surface, this proposal seems almost as straightforward as the previous two:
it adds new instructions that combine already existing behavior.

During the mechanization of this proposal, a mistake in the specification was noticed.
Before unwinding the stack when performing the return portion of the operation,
the values which are to be passed to the function being tail-invoked must first
be removed and then replaced after the frame of the ending function body is removed.
Before popping these values off the stack, it must be asserted that these values exist
in the correct number ($n$).
Initially, the specification mistakenly required that the stack must contain values
in number of the tail-invoked function's returned type instead of its input type,
but correctly removed $n$ values.
Thus, as initially written, the operation performed the correct operation, but did not check
that it was possible beforehand, resulting in unsafe operation.
This mistake was brought to the attention of the maintainers and was fixed
shortly thereafter\cite{TailInvokeIssue10}.

\chapter{Conclusions} % TODO

\chapter{Related Work} % TODO

\chapter{Future Work} % TODO

\chapter{Summary} % TODO

% \appendix

\clearpage

\bibliography{thesis,wasm-cg}
\addcontentsline{toc}{chapter}{Bibliography}

\end{document}
