\documentclass[12pt]{report}
\usepackage{uwmthesis}
\usepackage[colorlinks=true]{hyperref}
\usepackage{stmaryrd}
\usepackage[T1]{fontenc}
\usepackage{listings}
\lstset{
	mathescape,
	basicstyle=\small
}

\usepackage[square,numbers]{natbib}
\bibliographystyle{plainnat}

\begin{document}

\title{Mechanizing WebAssembly Proposals}
\author{Jacob Mischka}
\degree{Master of Science}
\Program{Computer Science}
\majorprof{John Boyland}
\algorithmspagefalse

\Abstract{% TODO
}


\beforepreface

\prefacesection{Preface}

% TODO

\Acks{%
	% TODO
}

\afterpreface

\chapter{Introduction}

With the only standardized and widely supported language for the Web being
JavaScript, it became more common for other languages to support JavaScript as
a compile target, with developers writing software in those other languages and
compiling the software to JavaScript to run on the Web.
Some of these source languages were designed intentionally with this goal in
mind, such as CoffeeScript.
The goals of these projects were to provide developers the same distribution
platform (the Web) but with the freedom of writing their programs in a
different syntax.
However, with the usage of the Web as a universal platform continued to expand,
authors of other projects wished to compile their software to be run on the
Web, but had strong reasons requiring the use of a different source language.
Often, this was a lower-level language used for
performance reasons, a stricter language for safety reasons, or support for
existing libraries or large projects in existing languages that cannot easily
be ported to JavaScript.
Often, this language is C or C++.

The Emscripten project compiles LLVM\footnote{\url{http://llvm.org/}} intermediate representation
software, which can be generated from C/C++, to JavaScript\cite{AboutEmscripten}.
The resulting compiled program utilizes a subset of JavaScript's available syntax and operations,
called asm.js,
which are heavily optimized by JavaScript interpreters and just-in-time compilers,
as well as the underlying hardware\cite{AsmJsResig}.

While this clever usage of the existing platform provided performance imrovements, JavaScript was
not designed as a low-level, performant compile target, and the resulting benefits of asm.js
relied heavily on JavaScript runtime implementations.
An attempt to define a formal specification and standardize the platform began
in 2013, but was abandoned shortly thereafter in 2014\cite{AsmJsSpec}.

The abandonment of asm.js's formalization coincided with discussions amongst its project
leaders for defining a new ``proper'' bytecode solution for native code on the Web; followed
shortly thereafter by initial discussions between browser developers and JavaScript runtime implementers
about ``WebAsm''.
As this project evolved and was fleshed out, the WebAssembly project began and was announced publicly
on June 17, 2015\cite{HistoryWasmTalk}.

\chapter{WebAssembly}

WebAssembly (Wasm) is a ``safe, portable, low-level code format designed for
efficient execution and compact representation''\cite[p. 1]{WasmSpec}.
WebAssembly defines a virtual instruction set that encapsulates programs
with it as their target, making them independent of the underlying platform
on which the program runs.
WebAssembly programs are executed by \textit{embedding environments}, which provide
an abstraction layer between the program and the underlying system. % FIXME: pluralization?

WebAssembly supports two official formats: a readable text format and a
more efficient binary format.

% TODO: Define embedders, VMs

In order to interact with the environment, WebAssembly embeddings
expose functionality via application programming interfaces (APIs):
defined functions that WebAssembly can use to interact with the environment.
With the Web as the primary embedding environment, Web embeddings provide
a defined JavaScript API that allows interaction between web pages.

WebAssembly provides safety guarantees by fully encapsulating logic and execution
at a low level.
Values consist of only 32- and 64-bit variants of integers and IEEE 754
floating point numbers\cite[p. 2--3]{WasmSpec}.
The operational semantics of the language is primarily that of a stack machine,
wherein operations are performed by removing operands from a last-in-first-out
stack of values and pushing the operation's result onto the stack afterward.
Strictly speaking this is not completely true, as the language's inclusion of
local variables allows circumvention of completely stack-based
execution\cite{WasmNotStackMachine}.
This has led to challenges for implementors of Lightbeam, an optimizing streaming
WebAssembly compiler\cite{IntroducingLightbeam}.

Memory operations are fully sandboxed by the WebAssembly execution environment.
WebAssembly memories are single lists of raw bytes\cite[p. 16]{WasmSpec}.
Each WebAssembly module can include a single memory vector, and any
computations the module performs that requires memory utilizes this list
of bytes, no direct access of the underlying system's physical or virtual memory
is permitted.

Embedding environments are free to expose any level of functionality to WebAssembly.
This is enabled by the concept of \textit{host functions}, functions provided by
the environment that can be invoked by WebAssembly code.
Host functions can receive and return values like regular functions, though they can
also modify the store\cite[p. 78]{WasmSpec}.
WebAssembly itself provides no guarantees about the determinism of host functions.
As far as WebAssembly is concerned, such functions can be assumed to succeed or
fail arbitrarily at the whims of the embedding environment.
If the function call succeeds, a compliant embedding environment is required to
correctly remove the expected number of arguments from the stack, and return
the declared number of values.
If the store is modified, the resulting store must be an extension of the previous
store, with only mutable contents modified and no contents removed, and its contents
must be well-typed.
Examples of host functions include functions for reading and writing system files or
performing network operations in a non-Web environment.


\section{Past experiments}

The concept of an alternative to JavaScript for running applications on the Web is not entirely new.
Two previous notable examples, embedded Flash applications and Java Applets, were once-popular
ways to write software that others could run in a web browser using other programming languages.
While they are similar in concept to WebAssembly, there are several fundamental differences that
allowed them to fall out of favor and eventually lead to the development of WebAssembly.

Firstly and primarily, both Flash and Java Applets were individual projects by
single organizations, Adobe and Oracle respectively, that operated in web browsers through
the use of plugins.
They were not \textit{part} of the standardized Web, they were instead isolated
boxes that ran inside of web pages once a user installed a separate piece of software
into their browsers that allowed them to work.

Secondly, because they were executed by their corresponding plugins,
such applications were unable to interact with the Web's Document Object Model.
They could not manipulate elements on the page or respond to events.

While WebAssembly is a language in itself that one could write directly,
it was designed from the beginning to be a standard compile target.
While it is possible to compile other languages to be executable by
the Java Virtual Machine and thus run in Java Applets, doing so is
analogous to compiling other languages to JavaScript so they can be executed on the
Web---not a first class way of writing software.

While WebAssembly does require its own execution environment
similarly to Flash and Java Applets, on the Web this environment is intertwined
heavily with existing JavaScript engines.

Finally, as previously mentioned, WebAssembly was designed with a major goal of
high performance.

Flash fell out of favor largely due to the release of the iPhone and its
intentional lack of support for Flash applications in its web browsers, along with
the advancement of more powerful open and standardized Web platform
features\cite{FlashKilledOff}.
Steve Jobs, CEO of Apple and the primary inventor of the iPhone, listed many of the
above reasons for his refusal to provide support\cite{ThoughtsOnFlash}.

% TODO: Describe memory model

\section{Non-Web Embeddings}

As its name implies, its primary focus is Web-based software; however it is not
specific or tied to the Web.
Other non-Web environments execute WebAssembly for a variety of reasons: its
safe memory model, its high performance, and it being a universal, encapsulated,
and independent compile target.
The last is particularly interesting given its bidirectional implications: a
programmer can truly write and compile a piece of software once and run it
nearly anywhere; and a programmer can depend on other software written in any
language that supports WebAssembly.

WASI (WebAssembly System Interface) is a project that defines a family of APIs
for WebAssembly to interact with a traditional system environment to perform
common, core tasks such as interaction with the filesystem and networking\cite{WasiOverview}.
These APIs are designed to be a common target for embedders to support, allowing optimal
portability of systems-focused WebAssembly programs while maintaining the security and
sandboxing of the WebAssembly platform\cite{StandardizingWasi}.

WASI's
\href{https://github.com/WebAssembly/WASI/blob/master/phases/snapshot/docs.md#-fd_readdirfd-fd-buf-pointeru8-buf_len-size-cookie-dircookie---errno-size}{\texttt{fd\_readdir}},
for example, is a host function that allows WebAssembly code to read the contents of a directory
on the environment's filesystem.

\section{Evolving WebAssembly}

The defined goals of the WebAssembly project details the process for evolving the language:
incrementally after providing a minimum viable product (MVP) core language specification and
implementation\cite{WasmHighLevelGoals}.
For the release of the 1.0 MVP, the main requirements of being a well-defined replacement for asm.js
with distributable modules, efficient binary bytecode, and high performance were the focus\cite{WasmMvp}.

Development of the specification takes place in public GitHub repositories.
Version 1.0 of the specification was tagged on July 20, 2019\cite{WasmWg1.0Release}.

While a large list of future features are at various levels of consideration for post-MVP Wasm,
the Community Group and Working Group utilize a phase-based proposal system for introducing,
discussing, and implementing additional features for WebAssembly\cite{WasmFutureFeatures}.

For a feature to be adopted into the language, a proposal must be drafted which passes through a sequence
of phases\cite{WasmW3CProcess}:

% FIXME: Update this when https://github.com/WebAssembly/meetings/pull/561 is merged
\begin{enumerate}
	\item[0] \textbf{Pre-Proposal}:
		A Community Group member files
		an issue to present the idea, and a proposal champion or champions
		emerges which submits the proposal to the Community Group's biweekly agenda.
		After being approved for general interest of research by the group,
		a proposal repository is created in the WebAssembly GitHub organization.

	\item[1] \textbf{Feature Proposal}:
		The proposal's repository is used to facilitate discussion about, and
		design and specification of, the feature.

	\item[2] \textbf{Proposed Specification Text Available}:
		Once the full proposed English specification text is available,
		prototype implementations for are created so that a test suite can be
		added for the new feature.

	\item[3] \textbf{Implementation Phase}:
		After a satisfactory test suite is created and passes for the feature
		in some implementation, embedders implement the feature and integrate
		the changes into the reference WebAssembly interpreter.

	\item[4] \textbf{Standardize the Feature}:
		After Web VMs and toolchains implement the feature and
		the Community Group reaches consensus for the feature and its design choices,
		the feature is handed off to the Working Group for final stages of discussion
		and handling of edge cases.
		The Community Group is responsible for major feature changes
		and design decisions, so the proposal is essentially frozen once being passed
		to the Working Group.

	\item[5] \textbf{The Feature is Standardized}:
		Consensus is reached by the Working Group that the feature is complete.
\end{enumerate}

In practice, in order to be deliberate about changes to the language, proposals can
take a great deal of time before reaching phase 5 and being fully integrated into
the WebAssembly specification.
As of the time of this writing, only five proposals have done
so\cite{FinishedProposals}.
The first such proposal was standardized relatively early in WebAssembly's
life---prior even to the initial 1.0 release---with the mutable globals
proposal\cite{MutableGlobalProposal} on June 6, 2018\cite{MeetingNotes2018-06-06}.
The multi-value proposal, which was in phase 4 at the time of the original
mechanization and already included in it, and the non-trapping float-to-int and
sign-extension operators proposals mechanized in this project were all integrated
at once on March 11, 2020\cite{MeetingNotes2020-03-11}.
Finally, the JavaScript BigInt to WebAssembly i64 Integration
proposal\cite{JSBigIntProposal}, a proposal which does not modify
the core WebAssembly language itself but the JavaScript API,
advanced on June 9, 2020\cite{MailingList2020-06-09}.
There are 23 currently outstanding proposals: 6 in phase 3, 4 in phase 2,
9 in phase 1, and 4 in the pre-proposal phase 0\cite{WasmProposals}.

Proposals may introduce relatively minor behavior changes or describe
major substantive modifications to the language.
No proposal is too small to be considered, though conversely larger
proposals with greater surface area require more deliberation and agreement
before being accepted.

Proposals may depend on one another.
For example, a notable proposal for Interface Types adds functionality to
describe high-level non-primitive values such as strings or records
so that values of these types can be passed between WebAssembly
modules\cite{InterfaceTypesProposalExplainer}.
Because these types are not primitive value types supported by WebAssembly
such as integers or floating point numbers, there must be way to refer
to these constructs indirectly.
Thus, the Interface Types proposal depends on the Reference Types
proposal, which adds typed reference values for functions and other external
types\cite{ReferenceTypesProposalOverview}.

The WebAssembly community consists of a collection of groups focused on
particular parts of the language and ecosystem.
The two primary groups involved with the development of the language and
ecosystem are the Working Group and Community Group.
The Working Group is an official World Wide Web Consortium (W3C) group
consisting of the primary group of stakeholders in charge with
steering the development of the language.
The Working Group currently is comprised of 48 participants representing
14 organizations including American organizations such as Google, Apple, Intel,
Facebook, and Microsoft, and organizations from other countries such as Tencent,
LG, and Huawei\cite{WorkingGroupParticipants}.
The Chair of the Working Group is Ben Smith, of Google.
The Community Group represents the broad community as a whole, and
all community members involved with or interested in the development of the
language are welcome; the only requirement is registering for a W3C account
and agreeing to the terms of the group.
The Community Group's meetings and discussions are facilitated primarily using
a dedicated GitHub repository\cite{CGMeetings}.
The Community Group hosts biweekly meetings via video conference.
Meeting minutes and supplemental materials are posted afterward in the repository,
and off-cycle discussion takes place in the repository's issue tracker.

In addition to the Community Group and Working Group, smaller subgroups target
more specific facets of the language or associated platforms.
As examples, there is the WASI subgroup for development of the WebAssembly
System Interface\cite{WasiSubgroup}, a Debugging subgroup for development of
debugging tools\cite{DebuggingSubgroup}, and subgroups for particularly
large and critical proposals such as the Interface Types, Garbage Collection,
and SIMD proposals.
Each subgroup determines its own meeting schedule and processes, though
there are discussions of unifying them\cite{SubgroupsProcessIssue}.

\chapter{Proof Mechanization} % TODO

\chapter{Soundness}

Typically, a programming language's type system is considered \textit{safe} or
\textit{sound} when it exhibits the following two primary properties\cite{pfpl2}:

\begin{enumerate}
	\item \textit{Preservation}: If an expression is well-typed and performs
		a step of evaluation, then the resulting expression maintains the
		original type.
	\item \textit{Progress}: If an expression is well-typed, it either
		has been reduced to a value, or it can be further evaluated.
\end{enumerate}

Core WebAssembly's type system is proved to be sound via a natural language
proof included in the specification\cite[p. 140]{WasmSpec}.
No additions will be allowed to the specification that knowingly violate
WebAssembly's soundness guarantees.
In order to confirm the soundness claims made by the rather terse proof,
a mechanized proof in Isabelle was developed separately\cite{WattMechanizing}.

\citeauthor{WattMechanizing}'s mechanization of core WebAssembly took place
separately from the development of the language, though proved crucial in
its foundation by identifying several major errors in the official WebAssembly
specification.
These issues were brought to the attention of the Working Group and
fixed, resulting in foundational language features such as exception propagation
and the \texttt{Return} operation to be rewritten\cite[p. 60-61]{WattMechanizing}.
Additionally, the declared requirements of host functions, functions provided
by the embedding environment that can be called by WebAssembly code, were
discovered to be too weak to maintain type safety and rewritten as a
result\cite[p. 61]{WattMechanizing}.

In addition to proving soundness of the core language via progress and
preservation, the original mechanization included several notable
additional properties.

Firstly, it included one proposal not existing in the initial version of the core language:
the Multi-value Proposal\cite{MultiValueProposal}.
In the original specification, functions and instructions can return at most one result.
This restriction is removed by the Multi-value Proposal, allowing multiple return
values for each\cite{MultiValueOverview}.

In addition to the soundness proof of the core language, the initial mechanization
included two separate modules which were also proven sound: an executable type
checker\cite[p. 61]{WattMechanizing} and an executable
interpreter\cite[p.62]{WattMechanizing}.


\chapter{Incremental Soundness} % TODO

My project builds on the existing Isabelle proof, extending the initial
mechanization to include extensions provided by three late-stage proposals:
Non-trapping Float-to-Int Conversions\cite{NontrappingFloatToIntProposal},
Sign Extension Operations\cite{SignExtensionOpsProposal},
and Tail Call\cite{TailCallProposal}.
Definitions and proofs for the type checker and interpreter are also updated
accordingly.

At the outset of my mechanization, two of the newly-mechanized proposals,
non-trapping float-to-int conversions and sign extension operations,
were at phase 4.
After the mechanized proofs were completed as part of this project,
they (along with the multi-value proposal already present in the initial
mechanization), have advanced to phase 5 and were fully integrated
into version 1.1 of the WebAssembly specification as of April 9,
2020\cite{Phase5Advancement}.
Tail call remains a phase 3 proposal currently in the implementation
phase\cite{WasmProposals}.


\section{Non-trapping Float-to-Int Conversions} % TODO

The first of the three mechanized, this proposal introduces 8 new
floating point truncation instructions of the form \\
\textit{(destination type)}\texttt{.trunc\_sat\_}\textit{(source type)}\texttt{\_}\textit{(signedness)}%
\cite{NontrappingFloatToIntOverview}:

\begin{itemize}
	\item \texttt{i32.trunc\_sat\_f32\_s}
	\item \texttt{i32.trunc\_sat\_f32\_u}
	\item \texttt{i32.trunc\_sat\_f64\_s}
	\item \texttt{i32.trunc\_sat\_f64\_u}
	\item \texttt{i64.trunc\_sat\_f32\_s}
	\item \texttt{i64.trunc\_sat\_f32\_u}
	\item \texttt{i64.trunc\_sat\_f64\_s}
	\item \texttt{i64.trunc\_sat\_f64\_u}
\end{itemize}

These new instructions are \textit{saturating}, meaning that their results are
limited to the maximum or minimum possible value for the given destination type.
Non-saturating versions of these instructions were present in the initial
release of WebAssembly, and were defined to trap in the event that
the floating point number could not be represented in the target integer type's
possible range of values, or in the event that the floating point number was
the special ``not a number'' value as defined by the IEEE floating point standard
(\texttt{NaN}).
Instead of trapping, these new instructions instead return the minimum or
maximum target integer value in case of underflow or overflow, and 0 in the
event that the source floating point number is \texttt{NaN}, resulting in
operations that never fail.

In the original mechanization, all numeric conversion instructions are
handled in a single \texttt{convert} function, which performs the appropriate
operations for the given instruction.
Because the non-saturating truncation instructions can fail, resulting in a trap,
\texttt{convert} returns an \texttt{Option} value, indicating \texttt{Some} value
if the conversion succeeded or \texttt{None} otherwise, indicating an impossible
conversion, or a conversion operation that failed and trapped.
Because these new instructions do not trap, I initially set out to model the
\texttt{convert\_sat} collection of operations so that they did not return an
\texttt{Option} and simply returned a value in all cases.
This was a mistake, as \texttt{convert} returns \texttt{None} not only
when the conversion failed, but also when no such instruction exists
to perform the conversion for the given types, such as a hypothetical
conversion from an \texttt{f64} to an \texttt{f64}.
In order for the new saturating conversion function to fit nicely
into the existing mechanization, it must to be able to return \texttt{None}
when the operation was impossible, such as converting to the same type as
the original input type.
After struggling to modify the surrounding proofs to handle such impossible
conversions elsewhere, reverting \texttt{convert\_sat} to return an
\texttt{Option} but always returning \texttt{Some} value when performing
a truncation resulted in a straightforward addition which maintained the
language's proof of soundness without requiring drastic changes to the
surrounding theorems and lemmas.

\section{Sign Extension Operators} % TODO

Similarly to the previous proposal, the Sign Extension Operators proposal
introduces several new numeric conversion operations which are similar to
existing instructions\cite{SignExtensionOpsOverview}:

\begin{itemize}
	\item \texttt{i32.extend8\_s}: extend a signed 8-bit integer to a 32-bit integer
	\item \texttt{i32.extend16\_s}: extend a signed 16-bit integer to a 32-bit integer
	\item \texttt{i64.extend8\_s}: extend a signed 8-bit integer to a 64-bit integer
	\item \texttt{i64.extend16\_s}: extend a signed 16-bit integer to a 64-bit integer
	\item \texttt{i64.extend32\_s}: extend a signed 32-bit integer to a 64-bit integer
\end{itemize}

Already present in the MVP release of WebAssembly are \texttt{i64.extend\_s}
and \texttt{i64.extend\_u}\cite[p. 11]{WasmSpec}, for extending a 32-bit
integer value (signed or unsigned, respectively) to a 64-bit integer value.
At first inspection, this seems like the only extension operations required,
as WebAssembly only supports 32- and 64-bit integers.
These new instructions, by contrast, do not actually modify the type of the
value, instead only its contents: \texttt{i32.extend8\_s} receives an
\texttt{i32} type as input and returns an \texttt{i32} type as output.
These new instructions reinterpret the contents of a value, operating
on smaller signed integer values packed inside the bits of one of
WebAssembly's integer types.
%                     â†“ Impossible?
While such cases are unlikely when using pure WebAssembly,
interaction with other environments or languages may result in
such values existing.

The distinction is confusing.
In fact, the distinction was even missed in initial discussions for this
proposal, resulting in \texttt{i64.extend32\_s} being dismissed as equivalent
to the existing \texttt{i64.extend\_s} instruction.
However, \texttt{i64.extend\_s} receives an \texttt{i32} type as input, returning
an \texttt{i64} type.
This contrasts with the behavior of the added instructions, which do not change
the type of the input but instead reinterpret its contents.
As such, \texttt{i64.extend32\_s} receives an \texttt{i64} type containing
the bits of a signed 32-bit integer and reinterprets it, without changing
the container's type, to an \texttt{i64} type containing a signed 64-bit integer.
This is indeed a distinct operation, and was hence added to the proposal
afterward\cite{SignExtensionOpsOverview}.

\section{Tail Call} % TODO

Like the previous two proposals mechanized in this project, the Tail Call
proposal also does not introduce any completely new behavior.
Core WebAssembly explicitly disallows tail-call optimizations for
functions that return the result of a function call.

% FIXME: Should I say "I"?
While performing the modeling for the proposal's mechanization, I encountered a
mistake in the proposed specification.
Before unwinding the stack when performing the return portion of the operation,
the values which are to be passed to the function being tail-invoked must first
be removed and then replaced after the frame of the ending function body is removed.
Before popping these values off the stack, it must be asserted that these values exist
in the correct number ($n$).
Initially, the specification mistakenly required that the stack must contain values
in number of the tail-invoked function's returned type instead of its input type,
but correctly removed $n$ values.
Thus, as initially written, the operation performed the correct operation, but did not check
that it was possible beforehand, resulting in unsafe operation.
This mistake was brought to the attention of the maintainers and was fixed
shortly thereafter\cite{TailInvokeIssue10}.

While the oversight was relatively minor in terms of size, only a single letter's
difference, finding otherwise easily-overlooked mistakes is one of the primary
strengths of mechanization in proofs.
Whereas the human eye can easily disregard a small typo or gloss over that
seems obvious, proof assistants insist that everything be proved without a doubt.

\chapter{Conclusions} % TODO

\chapter{Related Work} % TODO

\chapter{Future Work} % TODO

\chapter{Summary} % TODO

% \appendix

\clearpage

\bibliography{thesis,wasm-cg}
\addcontentsline{toc}{chapter}{Bibliography}

\end{document}
